module SkelNewGrammar where

-- Haskell module generated by the BNF converter

import AbsNewGrammar
import Types
import Stmt
import ErrM

import Control.Monad.Except
import Control.Monad.State
import Control.Monad.Reader
import qualified Data.Map as Map
import Data.Maybe(fromJust)


-- TODO !IMPORTANT! -- print, get, set !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!


transProgram2IO :: Program -> IO ()
transProgram2IO program = do
    outcome <- runStateT (runReaderT (runExceptT (transProgram program)) Map.empty) (Map.empty, 0)
    case fst outcome of
        Left (error, val) -> putStrLn error
        Right () -> return ()

transProgram :: Program -> ERSIO ()
transProgram (Program topdefs) = do
    env <- registerFuns topdefs
    local (\env' -> env) (transTopDefs topdefs)
    (store, loc) <- get
    val <- local (\env' -> env) (transExpr (EApp (Ident "main") []))
    case val of
        Int i -> do
            liftIO $ putStrLn $ "Main returned " ++ show i
        _ -> throwError $ string2error $ "Main return value should be int"


-- TODO: wrap it in foldM maybe?
registerFuns :: [TopDef] -> ERSIO Env
registerFuns [] = ask
registerFuns (topdef:topdefs) = do
    env <- registerFun topdef
    local (\env' -> env) (registerFuns topdefs)

-- reserve loc for func and change the env, but don't define function (in store loc for that func points to nothing)
registerFun :: TopDef -> ERSIO Env
registerFun (FnDef type_ f args block) = do
    env <- ask
    case Map.lookup f env of
        Just _ -> throwError $ string2error $ "Function " ++ show f ++ " is already defined"
        Nothing -> do
            loc <- getNewLoc
            modify (\(store, loc') -> (store, loc' + 1))
            return $ Map.insert f loc env

transTopDefs :: [TopDef] -> ERSIO ()
transTopDefs [] = return ()
transTopDefs (topdef:topdefs) = transTopDef topdef >> transTopDefs topdefs

transTopDef :: TopDef -> ERSIO ()
transTopDef (FnDef type_ ident args block) = do
    env <- ask
    let loc = fromJust $ Map.lookup ident env
    let fun_val = Fun block type_ env args
    modify (\(store, loc') -> (Map.insert loc fun_val store, loc'))
    return ()
