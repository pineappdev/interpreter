module SkelNewGrammar where

-- Haskell module generated by the BNF converter

import AbsNewGrammar
import Types
import Stmt
import ErrM

import Control.Monad.Except
import Control.Monad.State
import Control.Monad.Reader
import qualified Data.Map as Map
import Data.Maybe(fromJust)


-- TODO !IMPORTANT! -- print, get, set !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!


transProgram2IO :: Program -> IO ()
transProgram2IO program = do
    outcome <- runStateT (runReaderT (runExceptT (transProgram program)) Map.empty) (Map.empty, 0)
    case fst outcome of
        Left (error, val) -> putStrLn error
        Right () -> return ()

transProgram :: Program -> ERSIO ()
transProgram (Program topdefs) = do
    env <- registerFuns topdefs
    local (\env' -> env) (transTopDefs topdefs)
    (store, loc) <- get
    val <- local (\env' -> env) (transExpr (EApp (Ident "main") []))
    case val of
        Int i -> do
            liftIO $ putStrLn $ "Main returned " ++ show i
        _ -> throwError $ string2error $ "Main return value should be int"


-- TODO: wrap it in foldM maybe?
-- adds function names to the env (reserving locations), but doesn't change the store
registerFuns :: [TopDef] -> ERSIO Env
registerFuns [] = ask
registerFuns (topdef:topdefs) = do
    env <- registerFun topdef
    local (\env' -> env) (registerFuns topdefs)

transTopDefs :: [TopDef] -> ERSIO ()
transTopDefs [] = return ()
transTopDefs (topdef:topdefs) = transTopDef topdef >> transTopDefs topdefs
