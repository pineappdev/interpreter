module SkelGrammar where

-- Haskell module generated by the BNF converter

import AbsGrammar
import Types
import Stmt
import ErrM

import Control.Monad.Except
import Control.Monad.State
import Control.Monad.Reader
import qualified Data.Map as Map
import Data.Maybe(fromJust)


-- TODO !IMPORTANT! -- print, get, set !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!


transProgram2IO :: Show a => Program a -> IO ()
transProgram2IO program = do
    outcome <- runStateT (runReaderT (runExceptT (transProgram program)) Map.empty) (Map.empty, 0)
    case fst outcome of
        Left (error, val) -> putStrLn error
        Right () -> return ()

transProgram :: Show a => Program a -> ERSIO () a
transProgram (Program a topdefs) = do
    env <- registerFuns topdefs
    local (\env' -> env) (transTopDefs topdefs)
    (store, loc) <- get
    val <- local (\env' -> env) (transExpr (EApp a (Ident "main") []))
    case val of
        Int a i -> do
            liftIO $ putStrLn $ "Main returned " ++ show i
        _ -> throwError $ string2error $ show a ++ ": main return value should be int"


-- TODO: wrap it in foldM maybe?
-- adds function names to the env (reserving locations), but doesn't change the store
registerFuns :: Show a => [TopDef a] -> ERSIO (Env a) a
registerFuns [] = ask
registerFuns (topdef:topdefs) = do
    env <- registerFun topdef
    local (\env' -> env) (registerFuns topdefs)

transTopDefs :: Show a => [TopDef a] -> ERSIO () a
transTopDefs [] = return ()
transTopDefs (topdef:topdefs) = transTopDef topdef >> transTopDefs topdefs
