

module AbsNewGrammar where
import Data.List(intersperse)
-- Haskell module generated by the BNF converter




newtype Ident = Ident String deriving (Eq, Ord, Read)
instance Show Ident where
    show (Ident str) = str

data Program = Program [TopDef]
  deriving (Eq, Ord, Show, Read)

data TopDef = FnDef Type Ident [Arg] Block
  deriving (Eq, Ord, Show, Read)

data Arg = Arg Type Ident
  deriving (Eq, Ord, Read)

instance Show Arg where
    show (Arg type_ ident) = show type_ ++ " " ++ show ident

data Block = Block [Stmt]
  deriving (Eq, Ord, Show, Read)

data Stmt
    = Empty
    | BStmt Block
    | Break
    | Continue
    | Decl Type [Item]
    | FunDef TopDef
    | Ass Ident Expr
    | Ret Expr
    | Cond Expr Stmt
    | CondElse Expr Stmt Stmt
    | While Expr Stmt
    | SExp Expr
  deriving (Eq, Ord, Show, Read)

data Item = Init Ident Expr
  deriving (Eq, Ord, Show, Read)

data BaseType = IntT | StrT | BooleanT
  deriving (Eq, Ord, Read)

instance Show BaseType where
    show IntT = "int"
    show StrT = "string"
    show BooleanT = "bool"

data Type = BaseT BaseType | ArrayT BaseType | TupleT [Type]
  deriving (Eq, Ord, Read)

instance Show Type where
    show (BaseT baseType) = show baseType
    show (ArrayT baseType) = show baseType ++ "[]"
    show (TupleT types) = "Tuple<" ++ concat ( intersperse ", " (map show types)) ++ show ">"

data EArg = EArgE Expr | EArgName Ident
  deriving (Eq, Ord, Read)

instance Show EArg where
    show (EArgE expr) = show expr
    show (EArgName ident) = "&" ++ show ident

data Expr
    = EVar Ident
    | ELitInt Integer
    | ELitTrue
    | ELitFalse
    | EApp Ident [EArg]
    | EString String
    | ETuple [Expr]
    | EArray
    | Neg Expr
    | Not Expr
    | EMul Expr MulOp Expr
    | EAdd Expr AddOp Expr
    | ERel Expr RelOp Expr
    | EAnd Expr Expr
    | EOr Expr Expr
  deriving (Eq, Ord, Read)

showsPrecEArgs :: Int -> [EArg] -> ShowS
showsPrecEArgs prec [] = id
showsPrecEArgs prec (earg:earg2:eargs) = showsPrec prec earg . (showString ", ") . (showsPrecEArgs prec (earg2:eargs))
showsPrecEArgs prec (earg:eargs) = showsPrec prec earg

instance Show Expr where
    showsPrec prec (EVar ident) = showsPrec prec ident
    showsPrec prec (ELitInt i) = showsPrec prec i
    showsPrec prec ELitTrue = showString "true"
    showsPrec prec ELitFalse = showString "false"
    showsPrec prec (EApp ident eargs) = showsPrec prec ident . (showsPrec prec "(") . (showsPrecEArgs prec eargs) . (showsPrec prec ")")
    showsPrec prec (EString str) = showsPrec prec str
    showsPrec prec (ETuple exprs) = showsPrec prec exprs -- TODO: probably prec -> 2 or sth like this here
    showsPrec prec EArray = showsPrec prec "[]"
    showsPrec prec (Neg expr) = showParen (prec >= 10) $ showsPrec prec "-" . showsPrec 10 expr
    showsPrec prec (Not expr) = showParen (prec >= 10) $ showsPrec prec "!" . showsPrec 10 expr
    showsPrec prec (EMul expr1 mulop expr2) = showParen (prec >= 10) $ showsPrec 10 expr1 . showsPrec 10 mulop . showsPrec 10 expr2
    showsPrec prec (EAdd expr1 addop expr2) = showParen (prec >= 10) $ showsPrec 10 expr1 . showsPrec 10 addop . showsPrec 10 expr2
    showsPrec prec (ERel expr1 relop expr2) = showParen (prec >= 10) $ showsPrec 10 expr1 . showsPrec 10 relop . showsPrec 10 expr2
    showsPrec prec (EAnd expr1 expr2) = showParen (prec >= 10) $ showsPrec 10 expr1 . showString " && " . showsPrec 10 expr2
    showsPrec prec (EOr expr1 expr2) = showParen (prec >= 10) $ showsPrec 10 expr1 . showString " || " . showsPrec 10 expr2

data AddOp = Plus | Minus
  deriving (Eq, Ord, Read)

instance Show AddOp where
    show Plus = " + "
    show Minus = " - "

data MulOp = Times | Div | Mod
  deriving (Eq, Ord, Read)

instance Show MulOp where
    show Times = " * "
    show Div = " / "
    show Mod = " % "

data RelOp = LTH | LE | GTH | GE | EQU | NE
  deriving (Eq, Ord, Read)

instance Show RelOp where
    show LTH = " < "
    show LE = " <= "
    show GTH = " > "
    show GE = " >= "
    show EQU = " == "
    show NE = " != "
